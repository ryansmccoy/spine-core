"""Architectural invariant enforcement tests for spine-core.

These tests use AST-based import analysis to enforce layer boundaries.
They are generated by the architecture audit and should be run in CI
to prevent architectural drift.

Run with:
    uv run python -m pytest tests/test_arch_invariants.py -v
"""

from __future__ import annotations

import ast
import os
from pathlib import Path
from typing import NamedTuple

import pytest

SRC_ROOT = Path(__file__).resolve().parent.parent / "src"
SPINE_ROOT = SRC_ROOT / "spine"

# ── Layer definitions ──────────────────────────────────────────────
KERNEL = {"spine.core"}
FRAMEWORK = {"spine.framework"}
OPS = {"spine.ops"}
EXECUTION = {"spine.execution"}
ORCHESTRATION = {"spine.orchestration"}
DEPLOY = {"spine.deploy"}
TOOLS = {"spine.tools"}
OBSERVABILITY = {"spine.observability"}
TRANSPORTS = {"spine.api", "spine.cli", "spine.mcp"}
EXTENSIONS = EXECUTION | ORCHESTRATION | FRAMEWORK | OPS | DEPLOY | TOOLS | OBSERVABILITY

# ── Explicit bridge allowlist ──────────────────────────────────────
# Format: (from_module, to_layer_prefix) — only these cross-layer
# imports are permitted. Expand this list when bridges are intentional.
BRIDGE_ALLOWLIST: set[tuple[str, str]] = {
    # ops is the canonical bridge between transports and execution
    # (its whole purpose is to abstract execution details)
}


class ImportViolation(NamedTuple):
    """A detected import that violates layer boundaries."""
    file: str
    line: int
    imported: str
    rule: str


def _collect_imports(filepath: Path) -> list[tuple[int, str]]:
    """Parse a Python file and return (line_number, imported_module) pairs."""
    try:
        source = filepath.read_text(encoding="utf-8", errors="ignore")
        tree = ast.parse(source, filename=str(filepath))
    except SyntaxError:
        return []

    imports: list[tuple[int, str]] = []
    for node in ast.walk(tree):
        if isinstance(node, ast.Import):
            for alias in node.names:
                imports.append((node.lineno, alias.name))
        elif isinstance(node, ast.ImportFrom) and node.module:
            imports.append((node.lineno, node.module))
    return imports


def _module_path(filepath: Path) -> str:
    """Convert a file path to a dotted module path."""
    rel = filepath.relative_to(SRC_ROOT)
    parts = list(rel.with_suffix("").parts)
    if parts[-1] == "__init__":
        parts = parts[:-1]
    return ".".join(parts)


def _belongs_to(module: str, layer: set[str]) -> bool:
    """Check if a module belongs to any package in the layer."""
    return any(module == pkg or module.startswith(pkg + ".") for pkg in layer)


def _scan_layer(layer_packages: set[str]) -> list[Path]:
    """Get all .py files belonging to a set of packages."""
    files: list[Path] = []
    for pkg in layer_packages:
        pkg_dir = SRC_ROOT / pkg.replace(".", os.sep)
        if pkg_dir.exists():
            for pyfile in pkg_dir.rglob("*.py"):
                files.append(pyfile)
    return files


def _check_forbidden_imports(
    source_layer: set[str],
    forbidden_layers: set[str],
    rule_name: str,
) -> list[ImportViolation]:
    """Check that source_layer does not import from forbidden_layers."""
    violations: list[ImportViolation] = []
    for filepath in _scan_layer(source_layer):
        module = _module_path(filepath)
        for lineno, imported in _collect_imports(filepath):
            if _belongs_to(imported, forbidden_layers):
                # Check allowlist
                if (module, imported.split(".")[1] if "." in imported else imported) in BRIDGE_ALLOWLIST:
                    continue
                violations.append(ImportViolation(
                    file=str(filepath.relative_to(SRC_ROOT)),
                    line=lineno,
                    imported=imported,
                    rule=rule_name,
                ))
    return violations


# ── INV-1: Kernel never imports extensions ─────────────────────────
class TestKernelIsolation:
    """spine.core must not import from any extension layer."""

    # Known violations to fix — remove entries as they're resolved
    KNOWN_VIOLATIONS: set[str] = {
        "spine/core/service.py",  # imports spine.execution.dispatcher
    }

    def test_core_does_not_import_extensions(self) -> None:
        violations = _check_forbidden_imports(
            KERNEL,
            EXTENSIONS | TRANSPORTS,
            "INV-1: core must not import extensions or transports",
        )
        # Filter out known violations
        unexpected = [v for v in violations if v.file not in self.KNOWN_VIOLATIONS]
        if unexpected:
            msg = "NEW kernel isolation violations:\n"
            for v in unexpected:
                msg += f"  {v.file}:{v.line} imports {v.imported}\n"
            pytest.fail(msg)

    def test_known_violations_tracked(self) -> None:
        """Ensure known violations list doesn't grow."""
        violations = _check_forbidden_imports(
            KERNEL,
            EXTENSIONS | TRANSPORTS,
            "INV-1",
        )
        violation_files = {v.file for v in violations}
        # Warn about fixed violations still in the known list
        fixed = self.KNOWN_VIOLATIONS - violation_files
        if fixed:
            # This is good! Remove them from KNOWN_VIOLATIONS
            pass


# ── INV-2: Transports prefer ops over internal layers ──────────────
class TestTransportOpsPreference:
    """Transports should call ops, not execution/orchestration directly."""

    # Known bypasses — track these for gradual migration
    KNOWN_BYPASSES: set[str] = {
        "spine/api/routers/events.py",
        "spine/api/routers/examples.py",
        "spine/api/routers/functions.py",
        "spine/api/routers/playground.py",
        "spine/api/routers/deploy.py",
        "spine/cli/config.py",
        "spine/cli/deploy.py",
        "spine/cli/devtools.py",
        "spine/cli/events.py",
        "spine/cli/worker.py",
        "spine/cli/profile.py",
        "spine/cli/serve.py",
    }

    def test_no_new_transport_bypasses(self) -> None:
        """No new transport→execution/orchestration bypasses."""
        forbidden = EXECUTION | ORCHESTRATION
        violations = _check_forbidden_imports(
            TRANSPORTS,
            forbidden,
            "INV-2: transports should use ops, not execution/orchestration",
        )
        unexpected = [v for v in violations if v.file not in self.KNOWN_BYPASSES]
        if unexpected:
            msg = "NEW transport bypass violations:\n"
            for v in unexpected:
                msg += f"  {v.file}:{v.line} imports {v.imported}\n"
            pytest.fail(msg)


# ── INV-4: Ops never imports transports ────────────────────────────
class TestOpsIsolation:
    """spine.ops must not import from transport layers."""

    def test_ops_does_not_import_transports(self) -> None:
        violations = _check_forbidden_imports(
            OPS,
            TRANSPORTS,
            "INV-4: ops must not import transports",
        )
        assert not violations, "\n".join(
            f"  {v.file}:{v.line} imports {v.imported}" for v in violations
        )


# ── INV-5: Framework only imports core ─────────────────────────────
class TestFrameworkIsolation:
    """spine.framework should only import from spine.core and itself."""

    ALLOWED = KERNEL | FRAMEWORK

    def test_framework_imports_only_core(self) -> None:
        forbidden = EXECUTION | ORCHESTRATION | OPS | TRANSPORTS | DEPLOY
        violations = _check_forbidden_imports(
            FRAMEWORK,
            forbidden,
            "INV-5: framework must only import core",
        )
        assert not violations, "\n".join(
            f"  {v.file}:{v.line} imports {v.imported}" for v in violations
        )


# ── INV-6: No import cycles ───────────────────────────────────────
class TestNoCycles:
    """Detect bidirectional imports between layer pairs."""

    KNOWN_CYCLES: set[tuple[str, str]] = {
        ("spine.core", "spine.execution"),  # core/service.py → execution
    }

    def test_no_new_cycles(self) -> None:
        """Check for bidirectional imports between key layer pairs."""
        layer_pairs = [
            (KERNEL, EXECUTION, "core↔execution"),
            (KERNEL, ORCHESTRATION, "core↔orchestration"),
            (KERNEL, OPS, "core↔ops"),
            (OPS, TRANSPORTS, "ops↔transports"),
            (FRAMEWORK, EXECUTION, "framework↔execution"),
        ]
        new_cycles: list[str] = []
        for layer_a, layer_b, label in layer_pairs:
            a_to_b = _check_forbidden_imports(layer_a, layer_b, f"{label} (→)")
            b_to_a = _check_forbidden_imports(layer_b, layer_a, f"{label} (←)")
            if a_to_b and b_to_a:
                # Check if this is a known cycle
                cycle_key = (
                    min(next(iter(layer_a)), next(iter(layer_b))),
                    max(next(iter(layer_a)), next(iter(layer_b))),
                )
                if cycle_key not in self.KNOWN_CYCLES:
                    new_cycles.append(
                        f"  {label}: {len(a_to_b)} forward + {len(b_to_a)} reverse imports"
                    )
        if new_cycles:
            pytest.fail("NEW import cycles detected:\n" + "\n".join(new_cycles))


# ── INV-7: Registries are resettable ──────────────────────────────
class TestRegistryResettable:
    """Module-level registries must have reset() functions."""

    # Known registries to check
    REGISTRIES: list[tuple[str, str]] = [
        ("spine.core.dialect", "register_dialect"),
        ("spine.core.assets", "reset_asset_registry"),
        ("spine.core.feature_flags", "FlagRegistry"),
    ]

    def test_registries_have_reset(self) -> None:
        missing: list[str] = []
        for module_name, expected_symbol in self.REGISTRIES:
            try:
                mod = __import__(module_name, fromlist=[expected_symbol])
                if not hasattr(mod, expected_symbol):
                    missing.append(f"{module_name} missing {expected_symbol}")
            except ImportError:
                pass  # Module not available, skip
        assert not missing, "\n".join(missing)


# ── INV-8: Optional deps are lazy ─────────────────────────────────
class TestLazyOptionals:
    """Optional dependencies must not appear at module top level in core."""

    OPTIONAL_PACKAGES = {"asyncpg", "redis", "sqlalchemy", "pydantic_settings", "mcp", "fastapi"}

    def test_core_init_no_eager_optionals(self) -> None:
        """spine.core.__init__.py must not eagerly import optional deps."""
        init_file = SPINE_ROOT / "core" / "__init__.py"
        source = init_file.read_text(encoding="utf-8")
        tree = ast.parse(source)

        eager_imports: list[str] = []
        for node in ast.iter_child_nodes(tree):
            # Only check top-level imports (not inside functions/if blocks)
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if any(alias.name.startswith(pkg) for pkg in self.OPTIONAL_PACKAGES):
                        eager_imports.append(f"line {node.lineno}: import {alias.name}")
            elif isinstance(node, ast.ImportFrom) and node.module:
                if any(node.module.startswith(pkg) for pkg in self.OPTIONAL_PACKAGES):
                    eager_imports.append(f"line {node.lineno}: from {node.module}")

        assert not eager_imports, (
            "Optional deps eagerly imported at top level:\n"
            + "\n".join(f"  {e}" for e in eager_imports)
        )
